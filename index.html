<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>DPG — GeoJSON Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .topbar {
      position: absolute; top:0; left:0; right:0; z-index:1000;
      background:#111; color:#fff; padding:6px 10px;
      font-family: system-ui, sans-serif; font-size:14px;
      display:flex; gap:8px; align-items:center;
    }
    select { padding:3px 6px; border:none; border-radius:4px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar">
    <strong>DPG — GeoJSON Viewer</strong>
    <span>Arquivo:</span>
    <select id="fileSel"></select>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ====== Map base ======
  const map = L.map('map').setView([-14.2350,-51.9253], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    {maxZoom: 18, attribution: '&copy; OpenStreetMap'}).addTo(map);

  const rootGroup = L.layerGroup().addTo(map);
  const sel = document.getElementById('fileSel');

  // UI simples p/ camadas
  const topbar = document.querySelector('.topbar');
  const groupBox = document.createElement('span');
  groupBox.style.marginLeft = '10px';
  topbar.appendChild(groupBox);

  const groupsState = new Map(); // nome -> { group: L.LayerGroup, visible: bool }

  // ====== Carregar lista ======
  async function loadManifest(){
    const files = await fetch('manifest.json').then(r=>r.json());
    sel.innerHTML = '';
    for (const f of files){
      const opt = document.createElement('option');
      opt.value = f; opt.textContent = f;
      sel.appendChild(opt);
    }
    if (files.length) loadFile(files[0]);
  }

  // ====== Helpers ======
  function featureName(p={}) {
    return p.displayName || p.layerCode || p.tipo || '(sem nome)';
  }
  function pretty(obj){ return JSON.stringify(obj, null, 2); }

  function makePopup(layer, feat) {
    const p = feat.properties || {};
    const title = featureName(p);
    const el = document.createElement('div');
    el.style.minWidth = '260px';
    el.innerHTML = `
      <div style="font-weight:600;margin-bottom:6px">${title}</div>
      <pre style="white-space:pre-wrap;max-height:220px;overflow:auto;margin:0 0 8px 0">${pretty(p)}</pre>
      <button id="btnDel" style="background:#c62828;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">Excluir esta feature</button>
    `;
    // excluir a feature do mapa (apenas do viewer)
    el.querySelector('#btnDel').onclick = () => {
      const parent = layer.__parentGroup || rootGroup;
      parent.removeLayer(layer);
      map.closePopup();
    };
    return el;
  }

  function buildGroupsUI() {
    // limpa UI
    groupBox.innerHTML = '';
    if (!groupsState.size) return;

    // para cada "camada" (layerCode/tipo) cria um checkbox
    groupsState.forEach((state, name) => {
      const id = 'g_' + btoa(name).replace(/=/g,'');
      const wrap = document.createElement('label');
      wrap.style.marginLeft = '8px';
      wrap.title = 'mostrar/ocultar grupo';
      wrap.innerHTML = `
        <input id="${id}" type="checkbox" ${state.visible ? 'checked':''}>
        ${name}
      `;
      groupBox.appendChild(wrap);

      wrap.querySelector('input').addEventListener('change', (e) => {
        state.visible = e.target.checked;
        if (state.visible) {
          rootGroup.addLayer(state.group);
        } else {
          rootGroup.removeLayer(state.group);
        }
      });
    });

    // botão reset (recolocar tudo)
    const reset = document.createElement('button');
    reset.textContent = 'Resetar';
    reset.style.marginLeft = '8px';
    reset.style.padding = '4px 8px';
    reset.style.borderRadius = '6px';
    reset.onclick = () => {
      groupsState.forEach((state, name) => {
        state.visible = true;
        rootGroup.addLayer(state.group);
      });
      // marcar todos checkboxes
      groupBox.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = true);
    };
    groupBox.appendChild(reset);
  }

  // ====== Carregar arquivo ======
  async function loadFile(name){
    console.log('Carregando:', name);
    const res  = await fetch(name);
    const text = await res.text();
    // limpa possível prefixo de '+' em linhas (caso JSON tenha sido colado de diff)
    const clean = text.replace(/^\s*\+\s?/mg, '').trim();
    const data  = JSON.parse(clean);

    rootGroup.clearLayers();
    groupsState.clear();

    // agrupamos por layerCode/tipo para poder ocultar/mostrar
    const buckets = new Map(); // chave -> array de features
    for (const f of (data.features || [])) {
      const p = f.properties || {};
      const key = featureName(p);
      if (!buckets.has(key)) buckets.set(key, []);
      buckets.get(key).push(f);
    }

    // estilo/hover
    function styleFor(p={}) {
      const s = (p.rules && p.rules.style) || {};
      return {
        color: s.color || p.color || '#3388ff',
        weight: s.weight ?? 2,
        opacity: s.opacity ?? 1,
        fillColor: s.fillColor || p.fillColor || s.color || '#3388ff',
        fillOpacity: s.fillOpacity ?? 0.4
      };
    }

    // cria grupos por chave
    buckets.forEach((features, key) => {
      const group = L.layerGroup();
      features.forEach((feat) => {
        const p = feat.properties || {};
        const layer = L.geoJSON(feat, {
          style: () => styleFor(p),
          pointToLayer: (f, latlng) => {
            const s = styleFor(p);
            return L.circleMarker(latlng, {
              radius: (p.rules && p.rules.style && p.rules.style.radius) || 6,
              color: s.color, weight: s.weight, opacity: s.opacity,
              fillColor: s.fillColor, fillOpacity: s.fillOpacity
            });
          },
          onEachFeature: (f, lyr) => {
            // hover highlight
            const normal = styleFor(p);
            const hover  = {...normal, weight: (normal.weight||2) + 2};
            lyr.on('mouseover', () => {
              if (lyr.setStyle) lyr.setStyle(hover);
            });
            lyr.on('mouseout', () => {
              if (lyr.setStyle) lyr.setStyle(normal);
            });
            // popup com botão excluir
            const popup = makePopup(lyr, f);
            lyr.bindPopup(popup);
            // referência ao grupo para o botão excluir
            lyr.__parentGroup = group;
          }
        });
        group.addLayer(layer);
      });
      group.addTo(rootGroup);
      groupsState.set(key, {group, visible: true});
    });

    buildGroupsUI();

    // fit
    const all = rootGroup.getLayers();
    if (all.length) map.fitBounds(L.featureGroup(all).getBounds(), {maxZoom: 15});
  }

  sel.addEventListener('change', e => loadFile(e.target.value));
  loadManifest();
</script>
</body>
</html>