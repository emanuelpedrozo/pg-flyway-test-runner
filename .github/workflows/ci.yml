name: Flyway + Test CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgis/postgis:16-3.5
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: dpg_dev
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d dpg_dev"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10

    steps:
      - name: Checkout repositório
        uses: actions/checkout@v4

      - name: Instalar Flyway CLI
        run: |
          set -e
          curl -sL https://download.red-gate.com/maven/release/com/redgate/flyway/flyway-commandline/10.22.0/flyway-commandline-10.22.0-linux-x64.tar.gz \
            | tar xz
          sudo ln -sf "$PWD/flyway-10.22.0/flyway" /usr/local/bin/flyway
          flyway -v

      - name: Aplicar baseline e migrações
        env:
          FLYWAY_URL: jdbc:postgresql://localhost:5432/dpg_dev
          FLYWAY_USER: postgres
          FLYWAY_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          FLYWAY_SCHEMAS: geometry_bases
          FLYWAY_CLEAN_DISABLED: "true"
        run: |
          set -e
          flyway -locations=filesystem:./sql/baseline,filesystem:./sql/migrations migrate
          flyway info

      # ====== TESTES: gera saída "crua" dentro do container ======
      - name: Rodar TODOS os testes SQL (gera RAW)
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          set -euo pipefail
          mkdir -p tests_output

          uid="$(id -u)"
          gid="$(id -g)"

          docker run --rm --network host \
            --user "${uid}:${gid}" \
            -e PGPASSWORD="${PGPASSWORD}" \
            -v "${{ github.workspace }}/tests:/tests" \
            -v "${{ github.workspace }}/tests_output:/tests_output" \
            postgres:16 \
            sh -lc 'set -euo pipefail;
              ls -1 /tests/*.sql 2>/dev/null | while read -r f; do
                base="$(basename "$f" .sql)";
                echo "==> Executando $base.sql";
                psql -q -t -A -v ON_ERROR_STOP=1 -P pager=off -P footer=off \
                     -h localhost -p 5432 -U postgres -d dpg_dev \
                     -f "$f" > "/tests_output/${base}_raw.json";
              done;
              echo "Arquivos RAW em /tests_output:"; ls -lah /tests_output'

      # ====== Normaliza e valida JSONs fora do container ======
      - name: Normalizar e validar JSONs (gera *_result.json)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          echo "Listando arquivos RAW gerados:"
          ls -lah tests_output || true

          for raw in tests_output/*_raw.json; do
            base="$(basename "$raw" _raw.json)"
            out="tests_output/${base}_result.json"
            echo ""
            echo "==> Processando $raw -> $out"

            echo "Tamanho (bytes): $(wc -c < "$raw" || echo 0)"
            echo "Primeiras linhas (visíveis) do RAW:"
            # Mostra caracteres de controle (\r, \t etc.) com o final de linha marcado por $
            sed -n '1,20p' "$raw" | sed -n 's/[[:cntrl:]]/\\n/g; s/$/$/p' || true

            # Limpeza: remove CR, remove linhas que são apenas '+', remove '+' no fim da linha
            cleaned="$(
              sed -e 's/\r$//' "$raw" \
              | awk '{
                  t=$0; gsub(/^[ \t]+|[ \t]+$/, "", t);
                  if (t=="+") next;
                  print;
                }' \
              | sed -E 's/[[:space:]]*\+[[:space:]]*$//'
            )"

            if [ -z "${cleaned}" ]; then
              echo "::warning file=${raw}::Após limpeza ficou vazio. Vou copiar o RAW para ${out} para diagnóstico."
              cp -f "$raw" "$out" || true
              continue
            fi

            # Tenta validar como JSON; se falhar, grava mesmo assim e segue (para você inspecionar)
            if python3 - <<'PY' <<<"$cleaned"; then
          import sys, json
          json.loads(sys.stdin.read())
          PY
                      then
                        printf '%s' "${cleaned}" > "$out"
                        echo "[ok] JSON válido gravado: $out"
                      else
                        echo "::warning file=${raw}::Conteúdo não é JSON válido. Salvando mesmo assim em ${out} para inspeção."
                        printf '%s' "${cleaned}" > "$out"
                      fi
                    done

                    echo ""
                    echo "Arquivos finais em tests_output/:"
                    ls -lah tests_output


      - name: Upload dos artefatos de testes (.json)
        uses: actions/upload-artifact@v4
        with:
          name: sql-test-results
          path: tests_output/*_result.json
          if-no-files-found: error

      # ====== Monta a pasta do GitHub Pages ======
      - name: Montar site (viewer + json + manifest)
        run: |
          set -euo pipefail
          mkdir -p public
          cp .github/viewer_template.html public/index.html

          # Copia resultados
          cp tests_output/*_result.json public/ || true

          # Gera manifest.json com a lista dos arquivos *_result.json
          python3 - <<'PY' > public/manifest.json
          import json, os
          files = [f for f in os.listdir("public") if f.endswith("_result.json")]
          files.sort()
          print(json.dumps(files, ensure_ascii=False))
          PY

                    echo "Conteúdo de public/:"
                    ls -lah public

      - name: Publicar viewer no GitHub Pages
        if: ${{ hashFiles('public/*.json') != '' }}
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
